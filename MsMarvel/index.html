<style>
  body {
    margin: 0;
    background: #ffffff;
  }
</style>

<body>
  <canvas id = 'bg'> 
    
  </canvas>
</body>

<script
  async
  src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
></script>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
    }
  }
</script>



<script type="module">
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import * as THREE from 'three' 
import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
let mixer, animations, camera,model,  clock, activeAction, previousAction;
let robotVelocityX = 0;
let robotVelocityZ = 0;
let robotVelocityY = 0;
let robotPositionY = -1.75;
let isJumping = false;
let jumpVelocityY = 200;
let spawnRate = 200; // Defina a variável spawnRate no escopo global
let frames = 0;
let spawnTimer = 0;
let maxEnemies = 10;
const numEnemiesToSpawn = 5;
const jumpSpeed = 0.05;
const gravity = -0.005;
const textureLoader = new THREE.TextureLoader();
const scrapMetalTexture = textureLoader.load('./Public/scrap_metal.jpg');
const enemies = [] //inimigos
const enemyMaterial = new THREE.MeshPhongMaterial({
  map: scrapMetalTexture, // Use a textura como mapa
  flatShading: true,
  color: 0xffffff, 
});

const renderer = new THREE.WebGLRenderer({ //cria um renderizador que vai renderizar a cena a cada chamada nova.
  canvas: document.querySelector('#bg')
});
const scene = new THREE.Scene()  //cria a cena
scene.background = '0xffffff' 
const keys = {  //teclas
    a: {
      pressed: false,
    },
    d: {
      pressed: false,
    },
    s: {
      pressed: false,
    },
    w: {
      pressed: false,
    },
    Space: {
      pressed: false,
    }
  }

init(); //seta função iniciar
animate(); //seta função animar

function init(){ //define função iniciar
  camera = new THREE.PerspectiveCamera( 45, window.innerWidth /  window.innerHeight,
  0.1,
  1000
);
camera.position.set(4.61, 2.74, 8)
camera.lookAt( 0, 1, 0);
clock = new THREE.Clock();
window.addEventListener( 'resize', onWindowResize); // ajuste da tela
window.addEventListener( 'keydown', onKeyDown); // Tecla apertada
//window.addEventListener( 'keyup', onKeyUP); // tecla solta

}


renderer.shadowMap.enabled = true // seta a sombra inteligente
renderer.setSize(window.innerWidth, window.innerHeight) //tamanho tela
document.body.appendChild(renderer.domElement) 
//loader.load('/Public/goose_with_knife/scene.gltf', function(gltf){scene.add(gltf.scene);
  //gltf.scene.scale.set(0.04,0.04,0.04)})
// let MsMarvel = new Box
const mesh = new THREE.Mesh(); //mesh
const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
const boxMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00});
const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
const modelLoader = new GLTFLoader(); //cerrega modelo

modelLoader.load('./Public/RobotExpressive.glb', function ( gltf ){ //modelo carregado
  model = gltf.scene;
  mixer = new THREE.AnimationMixer (model);
  animations = gltf.animations; 
  activeAction = mixer.clipAction( gltf.animations [0]).play(); //animação base
  activeAction.play(); //ativa animação base
  scene.add(model); //adiciona modelo na cena
  model.position.set(0,-1.75,0)
  model.scale.set(0.3,0.3,0.3)

  model.traverse( (child) => {
if(child.isMesh) {
    child.castShadow = true
}
});
  animate();
})
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );
  window.addEventListener('resize', onWindowResize );

  function onWindowResize() { // tamanho da tela
    camera.aspect = window.innerWidth / window.innerHeight;
    renderer.setSize( window.innerWidth, window.innerHeight );
  }



  function animate() {
  requestAnimationFrame(animate);

  if (model) {
    previousAction = activeAction;

    spawnTimer++;
    if (spawnTimer >= spawnRate && enemies.length < maxEnemies) {
      spawnEnemy();
      spawnTimer = 0;
    }


    for (let i = enemies.length -1; i>= 0; i--) {
      const enemy = enemies[i];
      enemy.update();
      enemy.position.z += 0.1;

      if (enemy.position.z > 10) {
        scene.remove(enemy);
        enemies.splice(i, 1);
      }
    }

    const delta = clock.getDelta();
    mixer.update(delta);

    if (!isJumping) {
      robotPositionY += gravity;
    }

    model.position.x += robotVelocityX * delta;

    if (keys.a.pressed){
      mixer.clipAction( animations[6] ).play();
      robotVelocityX = -4;
    }
     else if (keys.d.pressed){
      mixer.clipAction( animations[6] ).play();
      robotVelocityX = 4;
     }
     else {
      robotVelocityX =0;
     }

    jumpVelocityY = 0.1;

     if (keys.Space.pressed && !isJumping) {
      isJumping = true;
      robotVelocityY = jumpVelocityY;
     }

     if (isJumping) {
      mixer.clipAction(animations[11]).play();
      robotPositionY += robotVelocityY * delta;
     

     if (robotPositionY <= -1.75) {
      robotPositionY = -1.75;
      robotVelocityY = 0;
      isJumping = false;
     } else {
      robotVelocityY += gravity * delta;
     }
    } else {
      if (robotPositionY <= -1.75) {
        robotPositionY = -1.75;
      }
      mixer.clipAction(animations[6]).play();
    }

    model.position.y = robotPositionY;

     enemies.forEach((enemy) => {
      enemy.update(ground);
     });

    renderer.render( scene, camera );
    if(previousAction !== activeAction)
    {
      previousAction.fadeOut( 0.5 ); // corrige os frames
      activeAction.reset()
                  .setEffectiveTimeScale( 1 )
                  .setEffectiveWeight( 1 )
                  .fadeIn( 0.5 )
                  .play();
    }
    //console.log(animations)
    robotPositionY += gravity * delta;
  } 
}

  function onKeyDown(event){

    previousAction = activeAction;

    switch(event.code){
      case 'Space':
      keys.Space.pressed = true; 
      if (!isJumping) {
        isJumping = true;
        robotVelocityY += jumpSpeed;
      }
      break; 

    }
    if(previousAction !== activeAction)
    {
      previousAction.fadeOut( 0.5 );
      activeAction.reset()
                  .setEffectiveTimeScale( 1 )
                  .setEffectiveWeight( 1 )
                  .fadeIn( 0.5 )
                  .play();
    }
  }

previousAction = activeAction;

// switch(event.code){
//   case 'Digit1':
//     activeAction = mixer.clipAction( animations[0] );
//     break
//   case 'Digit2':
//     activeAction = mixer.clipAction( animations[1] );
//     break
//   case 'Digit3':
//     activeAction = mixer.clipAction( animations[2] );
//     break
//   case 'Digit4':
//     activeAction = mixer.clipAction( animations[3] );
//     break
// }

  if(previousAction !== activeAction){
    previousAction.fadeOut( 0.5 );
    activeAction.reset()
                .setEffectiveTimeScale( 1 )
                .setEffectiveWeight( 1 )
                .fadeIn( 0.5 )
                .play();
  }

const controls = new OrbitControls(camera, renderer.domElement)
// const textureLoader = new THREE.TextureLoader();
// const scrapMetalTexture = textureLoader.load('./Public/scrap_metal.jpg');

class Box extends THREE.Mesh{

constructor({ width,flatshading, height,depth, color = '#00ff00', velocity = {x : 0, y : 0, z : 0}, position = {x : 0, y : 0, z : 0}, zAcceleration = false }) {
  super(

  new THREE.BoxGeometry(width, height, depth), 
  new THREE.MeshPhongMaterial({ color }))
  this.height = height
  this.width = width
  this.depth = depth
  this.flatshading = flatshading

  this.position.set(position.x, position.y, position.z)

  this.right = this.position.x + this.width / 2
  this.left = this.position.x - this.width / 2

  this.bottom = this.position.y - this.height / 2
  this.top = this.position.y + this.height /2

  this.front = this.position.z + this.depth / 2
  this.back = this.position.z - this.depth / 2


  this.velocity = velocity 
  this.gravity = -0.002

  this.zAcceleration = zAcceleration

}

updateSides() {
  this.right = this.position.x + this.width / 2
  this.left = this.position.x - this.width / 2

  this.bottom = this.position.y - this.height / 2
  this.top = this.position.y + this.height / 2

  this.front = this.position.z + this.depth / 2
  this.back = this.position.z - this.depth / 2
}

update(ground) { //cria o chão
  this.updateSides()
  if (this.zAcceleration) this.velocity.z += 0.0003

  this.position.x += this.velocity.x
  this.position.z += this.velocity.z

  if (this.zAcceleration){
    this.velocity.z += 0.0003;
  }

  this.position.x += this.velocity.x; 
  this.position.z += this.velocity.z;

  this.applyGravity(ground)
}

applyGravity(ground){
  this.velocity.y += this.gravity
  

  if (this.bottom + this.velocity.y <= ground.top) {

    this.velocity.y = -this.velocity.y

    if (
          boxCollision({
            box1: this,
            box2: ground
          })
        ) {
          const friction = 0.5
          this.velocity.y *= friction
          this.velocity.y = -this.velocity.y
        } else this.position.y += this.velocity.y

  }
  else this.position.y += this.velocity.y
}
}


function boxCollision({ box1, box2 }) { //colisao
const xCollision = box1.right >= box2.left && box1.left <= box2.right
const yCollision =
  box1.bottom + box1.velocity.y <= box2.top && box1.top >= box2.bottom
const zCollision = box1.front >= box2.back && box1.back <= box2.front

return xCollision && yCollision && zCollision
}

const cube = new Box({
  width: 1,
  height: 1,
  depth: 1,
  velocity: {
    x:0, y:-0.01, z:0
  }
})
cube.castShadow = true
//scene.add(cube)

renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);
    

  const ground =  new Box({
    width: 10,
    height: 0.5,
    depth: 50,
    color: '#0369a1',
    position: {x:0, y:-2, z:0}
  })

    ground.receiveShadow= true
    ground.position.y = -2
    scene.add(ground)

  
  const light = new THREE.DirectionalLight(0xffffff, 1) //luzes
  light.position.y = 5
  light.castShadow = true
  light.position.z = 5
  light.position.x = 5
  scene.add(light)
  camera.position.z = 5
  console.log(ground.top)
  console.log(cube.bottom)
  scene.add(light)


  let lightHelper = new THREE.PointLightHelper(light,1); //mostra onde a luz está projetando
    scene.add(lightHelper);



  window.addEventListener('keydown', (event) => {
    switch(event.code){
      case 'KeyA':
      keys.a.pressed = true
      break
      case 'KeyD':
      keys.d.pressed = true
      break
      case 'KeyS':
      keys.s.pressed = true
      break
      case 'KeyW':
      keys.w.pressed = true
      break
    }


  })

  window.addEventListener('keyup', (event) => {
    switch(event.code){
      case 'KeyA':
      keys.a.pressed = false
      break
      case 'KeyD':
      keys.d.pressed = false
      break
      case 'KeyW':
      keys.w.pressed = false
      case 'KeyS':
      keys.s.pressed = false
    }

  
  })
 
  // function animate() {
  //   const animationId = requestAnimationFrame(animate)
  //   renderer.render(scene, camera)

  //   cube.position.x += 0
  //   cube.position.z += 0
  //   cube.position.y += 0
  //   if (keys.a.pressed) cube.velocity.x = -0.05
  //   else if (keys.d.pressed) cube.velocity.x = 0.05

  //   if (keys.s.pressed) cube.velocity.z = 0.05
  //   else if (keys.w.pressed) cube.velocity.z = -0.05

  //   cube.update(ground)
  //   enemies.forEach(enemy => {
  //     enemy.update(ground)
  //     if (boxCollision({
  //       box1: cube,
  //       box2: enemy
  //     })
  //     ){
  //       cancelAnimationFrame(animationId)
  //     }
  //   })
  // }
  
  class Enemy extends THREE.Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.velocity = new THREE.Vector3(0, 0, 0.1); // Velocidade do inimigo
  }

  update() {
    this.position.add(this.velocity);
   if (this. position.z > 10){
    this.position.z = -20; // Reinicia a posição do inimigo
      this.position.x = (Math.random() - 0.5) * 10; // Posição horizontal aleatória
   }
  }
}



function spawnEnemy() {
  if(enemies.length < maxEnemies){
  const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
  const enemyMaterial = new THREE.MeshPhongMaterial({
    map: scrapMetalTexture, // Use the texture as the map
    flatShading: true,
    color: 0xffffff,
  });

  const enemy = new Enemy(enemyGeometry, enemyMaterial); // Create enemies using the Enemy class
  enemy.position.set(
    (Math.random() - 0.5) * 10,
    0,
    -20
  );
  enemy.castShadow = true;
  scene.add(enemy);
  enemies.push(enemy);
}
}

function spawnEnemies() {
  for (let i = 0; i < numEnemiesToSpawn; i++) {
    spawnEnemy();
  }
}


if (frames % spawnRate === 0) {
  if (spawnRate > 20) spawnRate -= 20;
  spawnEnemies();
}

spawnEnemies();

frames++;
animate(); // chama para animar
  // const enemyMaterial = new THREE.MeshPhongMaterial({
    //   map: scrapMetalTexture,
    //   flatShading: true,
    //   color: 0xffffff
    // })
</script>