<style>
  body {
    margin: 0;
    background: #0c4a6e;
  }
</style>

<script
  async
  src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
></script>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
    }
  }
</script>



<script type="module">
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import * as THREE from 'three'
import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
let mixer, animations, camera, clock, activeAction, previousAction, renderer;

init();
animate();

function init(){
  camera = new THREE.PerspectiveCamera( 45, window.innerWidth /  window.innerHeight,
  0.1,
  1000
);
camera.position.set(4.61, 2.74, 8)
camera.lookAt( 0, 1, 0);
clock = new THREE.Clock();
window.addEventListener( 'resize', onWindowResize);
window.addEventListener( 'keydown', onKeyDown);

}

const scene = new THREE.Scene()

renderer.shadowMap.enabled = true
renderer.setSize(window.innerWidth, window.innerHeight)
document.body.appendChild(renderer.domElement)
//loader.load('/Public/goose_with_knife/scene.gltf', function(gltf){scene.add(gltf.scene);
  //gltf.scene.scale.set(0.04,0.04,0.04)})
// let MsMarvel = new Box;

const mesh = new THREE.Mesh();
const modelLoader = new GLTFLoader();
modelLoader.load('Public/RobotExpressive.glb', function ( gltf ){
  const model = gltf.scene;
  mixer = new THREE.AnimationMixer (model);
  animations = gltf.animations;
  activeAction = mixer.clipAction( gltf.animations [0]).play();
  activeAction.play();
  scene.add(model.scene);
  model.position.set(0,1,0)
  model.scale.set(0.4,0.4,0.4)
  model.traverse( (child) => {
// if (child.isMesh) child.material = angryTexture;
if ( child.material ) 
    {child.material.metalness = 0}
if(child.isMesh) {
    child.castShadow = true
}
});
  animate();
})
  // renderer = new THREE.WebGLRenderer( { antialias: true});
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );
  // document.body.appendChild( renderer.domElemt);
  window.addEventListener('resize', onWindowResize );

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    renderer.setSize( window.innerWidth, window.innerHeight );
  }

  function animate() {
    requestAnimationFrame( animate );

    const delta = clock.getDelta();
    if(mixer){
      mixer.update( delta );
    }
    renderer.render( scene, camera );
  }

  function onKeyDown(event){

    previousAction = activeAction;

    switch(event.code){
      case 'Digit1':
        activeAction = mixer.clipAction( animations[0] );
        break
      case 'Digit2':
        activeAction = mixer.clipAction( animations[1] );
        break
      case 'Digit3':
        activeAction = mixer.clipAction( animations[2] );
        break
      case 'Digit4':
        activeAction = mixer.clipAction( animations[3] );
        break
    }
  }
  if(previousAction !== activeAction){
    previousAction.fadeOut( 0.5 );
    activeAction.reset()
                .setEffectiveTimeScale( 1 )
                .setEffectiveWeight( 1 )
                .fadeIn( 0.5 )
                .play();
  }
// model = await modelLoader.loadAsync( 'Public/RobotExpressive.glb', function ( gltf ){ 
//   mixer = new THREE.AnimationMixer (model);
//   mixer.clipAction( gltf.animations [0]).play();
//   scene.add(model.scene);
// })
  
  

  


// Play a specific animation
//const clip = THREE.AnimationClip.findByName( clips, 'jump' );
//const action = mixer.clipAction( clip );
//action.play();

  
// var model;
// model = await modelLoader.loadAsync('/Public/goose_with_knife/scene.gltf');
// scene.add(model.scene)
// // model = await modelLoader.loadAsync('./models/pelotitus/male/pelotitus_male.gltf')
// model = model.scene;
// model.position.set(0,1.8,0);
// model.scale.set(0.04,0.04,0.04)
// // model.scale.set(10,10,10);
// model.traverse( (child) => {
// // if (child.isMesh) child.material = angryTexture;
// if ( child.material ) 
//     {child.material.metalness = 0}
// if(child.isMesh) {
//     child.castShadow = true
// }
// });
// console.log(model)

const controls = new OrbitControls(camera, renderer.domElement)

// class Ganso {
//   model;
//   scene;
//   constructor(model, scene){this.model = model; this.scene = scene}
// }

//let player = new Ganso (model, scene)

    
// class Robot extends THREE.Mesh{
//   constructor({width, color, height, depth, velocity = {x: 0, y: 0, z:0}, position = {x: 0, y: 0, z: 0}, zAcceletarion = false, model }){
//     super(new THREE.MeshStandardMaterial({color}))
    
//     this.height = height
//     this.width = width
//     this.depth = depth
//     this.color = color
//     model.scale.set(0.4,0.4,0.4)
//     scene.add(model.scene);
//     model = model.scene;
    
//     this.position.set(position.x, position.y, position.z)
    
//     this.right = this.position.x + this.width / 2
//     this.left = this.position.x - this.width / 2
    
//     this.bottom = this.position.y - this.height / 2
//     this.top = this.position.y + this.height /2
    
//     this.front = this.position.z + this.depth / 2
//     this.back = this.position.z - this.depth / 2
    
    
//     this.velocity = velocity 
//     this.gravity = -0.002
    
//     this.zAcceleration = zAcceleration
    
//     //console.log(color);
//   }
// }


class Box extends THREE.Mesh{

  constructor({ width, height,depth, color = '#00ff00', velocity = {x : 0, y : 0, z : 0}, position = {x : 0, y : 0, z : 0}, zAcceleration = false }) {
    super(

    new THREE.BoxGeometry(width, height, depth), 
    new THREE.MeshStandardMaterial({ color }))
    this.height = height
    this.width = width
    this.depth = depth

    this.position.set(position.x, position.y, position.z)

    this.right = this.position.x + this.width / 2
    this.left = this.position.x - this.width / 2

    this.bottom = this.position.y - this.height / 2
    this.top = this.position.y + this.height /2

    this.front = this.position.z + this.depth / 2
    this.back = this.position.z - this.depth / 2


    this.velocity = velocity 
    this.gravity = -0.002

    this.zAcceleration = zAcceleration

    //console.log(color)
  }

  updateSides() {
    this.right = this.position.x + this.width / 2
    this.left = this.position.x - this.width / 2

    this.bottom = this.position.y - this.height / 2
    this.top = this.position.y + this.height / 2

    this.front = this.position.z + this.depth / 2
    this.back = this.position.z - this.depth / 2
  }

  update(ground) {
    this.updateSides()
    if (this.zAcceleration) this.velocity.z += 0.0003

    this.position.x += this.velocity.x
    this.position.z += this.velocity.z
    this.applyGravity(ground)
  }

  applyGravity(ground){
    this.velocity.y += this.gravity
    

    if (this.bottom + this.velocity.y <= ground.top) {

      this.velocity.y = -this.velocity.y

      if (
            boxCollision({
              box1: this,
              box2: ground
            })
          ) {
            const friction = 0.5
            this.velocity.y *= friction
            this.velocity.y = -this.velocity.y
          } else this.position.y += this.velocity.y

    }
    else this.position.y += this.velocity.y
  }
}
 

function boxCollision({ box1, box2 }) {
  const xCollision = box1.right >= box2.left && box1.left <= box2.right
  const yCollision =
    box1.bottom + box1.velocity.y <= box2.top && box1.top >= box2.bottom
  const zCollision = box1.front >= box2.back && box1.back <= box2.front

  return xCollision && yCollision && zCollision
}
    
// const robo = new Robot({
//   width: 1,
//   height: 1,
//   depth: 1,
//   color: '#0369a1',
//   model: modelLoader.loadAsync('Public/RobotExpressive.glb'),
//   velocity: {
//     x:0, y:-0.01, z:0
//   }
// })
// robo.castShadow = true
// scene.add(robo)

const cube = new Box({
  width: 1,
  height: 1,
  depth: 1,
  velocity: {
    x:0, y:-0.01, z:0
  }
})
cube.castShadow = true
scene.add(cube)

renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);
    

  const ground =  new Box({
    width: 10,
    height: 0.5,
    depth: 50,
    color: '#0369a1',
    position: {x:0, y:-2, z:0}
  })

    ground.receiveShadow= true
    ground.position.y = -2
    scene.add(ground)

  const light = new THREE.DirectionalLight(0xffffff, 1)
  light.position.y = 3
  light.position.z = 1
  scene.add(light)
  camera.position.z = 5
  light.castShadow = true
  console.log(ground.top)
  console.log(cube.bottom)
  scene.add(light)

  const keys = { 
    a: {
      pressed: false
    },
    d: {
      pressed: false
    },
    s: {
      pressed: false
    },
    w: {
      pressed: false
    }
  }

  window.addEventListener('keydown', (event) => {
    switch(event.code){
      case 'KeyA':
      keys.a.pressed = true
      break
      case 'KeyD':
      keys.d.pressed = true
      break
      case 'KeyS':
      keys.s.pressed = true
      break
      case 'KeyW':
      keys.w.pressed = true
      break
    }


  })

  window.addEventListener('keyup', (event) => {
    switch(event.code){
      case 'KeyA':
      keys.a.pressed = false
      break
      case 'KeyD':
      keys.d.pressed = false
      break
      case 'KeyW':
      keys.w.pressed = false
      case 'KeyS':
      keys.s.pressed = false
    }

  
  })

    const enemies = []
    let frames = 0
    let spawnRate = 200  
  // function animate() {
  //   const animationId = requestAnimationFrame(animate)
  //   renderer.render(scene, camera)

  //   cube.position.x += 0
  //   cube.position.z += 0
  //   cube.position.y += 0
  //   if (keys.a.pressed) cube.velocity.x = -0.05
  //   else if (keys.d.pressed) cube.velocity.x = 0.05

  //   if (keys.s.pressed) cube.velocity.z = 0.05
  //   else if (keys.w.pressed) cube.velocity.z = -0.05

  //   cube.update(ground)
  //   enemies.forEach(enemy => {
  //     enemy.update(ground)
  //     if (boxCollision({
  //       box1: cube,
  //       box2: enemy
  //     })
  //     ){
  //       cancelAnimationFrame(animationId)
  //     }
  //   })
  // }
  

  if (frames % spawnRate === 0){
    if (spawnRate > 20) spawnRate -=20

    const enemy = new Box({
    width: 1,
    height: 1,
    depth: 1,
    position: {
      x: (Math.random() - 0.5) * 10,
      y:0,
      z:-20 
    },
    color: '#FF0000',
    velocity: {x:0, y:0, z:0.005},
    zAcceleration: true
  }, 
  )
    enemy.castShadow = true
    scene.add(enemy)
    enemies.push(enemy)
  }

  frames++
  animate()
</script>